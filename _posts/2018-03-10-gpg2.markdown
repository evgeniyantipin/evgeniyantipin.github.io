---
layout: post
title: 'Введение в GnuPG'
date: 2018-03-11 17:26:10
---

[comment]: # (http://www.ianatkinson.net/computing/gnupg.htm)

Это короткое пособие объясняет лишь некоторые базовые возможности GnuPG, больше информации можно найти воспользовшись коммандой `man gpg2`.

## Немного теории
GnuPG - это реализация программы PGP (Pretty Good Privacy), которая состоит из пары ключей: public и private.
Особенностью данного метода шифрования является подход, когда файл может быть зашифрован для конкретного получателя используя его public ключ, когда для расшифровки файла, в свою очередь, понадобятся оба (public и private) ключа. Таким образом, идея заключается в том, чтобы предоставить ваш public ключ вашим друзьям или коллегам, но хранить private ключ надежно защищенным и не предоставлять его никому. 

В GnuPG оба ваших ключа ассоциированны с id, который состоит из вашего имени, адреса электронной почты и комментария. Когда вы указываете получателя зашифрованного файла, вы можете использовать имя или адрес электронной почты (я буду использовать email).

Ваш private ключ защишен паролем и соответствнно, требует ввода пароля для использования. Это добавляет ещё один уровень авторизации, в случае, если кто-то получит физический доступ к вашему компьютеру.

## Установка
Если вы используете Linux, то скорее всего в вашем дистрибьютиве уже есть предустановленные пакеты GnuPG. Я использую Fedora 27 и в нём присутствует целых две версии GnuPG. Проверить это можно введя в консоли комманду `gpg --version` или `gpg2 --version`. Я использую gpg2, так как в моей системе есть ряд пакетов (например pass), которые имеют зависимости от gpg2. Если пакет gpg2 отсутствует в вашей системе, то его можно установить используя ваш пакетный менеджер, для Fedora например это выглядит так: `sudo dnf install gnupg2`.

## Генерируем ключи
Для того чтобы сгенерировать новую пару ключей, вам нужно дать комманду `gpg2` с аттрибутом `--full-gen-key`. 
Вам будет предложено несколько вариантов шифрования:
```bash
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 
```
В большинстве случаев первый вариант является подходящим. 
Пара RSA/RSA позволит вам подписывать ваши коммуникации, а также шифровать файлы.
Следующий шаг - выбор размер ключа:
```bash
RSA keys may be between 1024 and 4096 bits long.  
Larger is  almost  always recommended here, however your use case and  security models may dictate otherwise.
What keysize do you want? (2048) 
```
Вариант предложенный по умолчанию (2048), подойдет большинству пользователей и представлает очень высокий уровень безопасности при шифровании. 
Далее нам нужно выбрать срок действия ключей:
```bash
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months 
      <n>y = key expires in n years
Key is valid for? (0) 
```
Значение по умолчанию предпологает бессрочный срок действия ключа. Выбирите подходящий срок (после генерации ключа, это значение можно будет изменить), после чего gpg2 потребует подтвердить корректность введенной информации:
```bash
Is this correct (y/n)?
```
Следующий шаг после подтверждения - ввод своего реального имени, электронной почты и опционально - комментария.
Также на этом шаге потребуется ввести пароль для ключа.
После ввода всех нужных данных и подтверждения их корректности gpg2 сгенерирует пару ключей и выдаст информацию о новых ключах на экран: 
```bash
pub  1024D/1C2BFG1D 2018-03-11 Evgenii A. Antipin <antipin@antipin.com>
Key fingerprint = 129C DG83 32ED C732 5A49  6884 2330 644E 2C2A FA1B
sub  1024g/AE3B22E 2018-03-11 [expires: 2020-03-11] 
```
Теперь, когда процесс генерации завершен, у вас есть две коллекции ключей (keyrings): public keyring и private keyring.
Ваша public коллекция ключей пока содержит только ваш собственный public ключ. Вы можете посмотреть ее введя комманду `gpg2` с аттрибутом `--list-keys`. 
Когда кто-либо еще предоставит вам свои public ключи, для того чтобы вы могли отправлять им зашифрованные файлы, эти ключи также появятся здесь.

Вы также можете посмотреть вашу private коллекцию ключей, которая содержит ваш private ключ, введя комманду `gpg2` с аттрибутом `--list-secret-keys`.

## Шифрование файла
Теперь когда у нас есть пара ключей, мы можем шифровать файлы. Давайте попробуем сделать это.
Создайте простой текстовый файл в удобной для вас директории:
```bash
echo 'this is my very secret file' > secret.txt
```
А теперь мы зашифруем файл secret.txt, явно указывая получателя как себя самого: технически мы можем сделать это, поскольку мы имеем наш собственный public ключ (а соответственно и ассоциированный с ним email) в нашей коллекции public ключей.
Мы будем использовать параметр `-e` (encrypt) вместе с `-r` (recepient) и почтой получателя, завершая это именем файла, который мы будем шифровать:
```bash
gpg2 -e -r your@email.com secret.txt
```
Как вы можете видеть, в результате выполнения данной комманды мы получили новый (зашифрованный) файл, с тем же самым именем, что и оригинальный, но с дополнительным расширением .gpg: secret.txt.gpg. Это кажется разумным решением, например, когда оба файла: оригинал и зашифрованная копия находятся в одном каталоге. Визуально можно сразу увидеть, какие файлы зашифрованы. 
Однако, если вы не хотите привлекать лишнего внимания к файлам с явным расширением .gpg, вы можете избавиться от него указав аргумент `-o` (output) и желаемое имя файла на выходе:
```bash
gpg2 -e -r your@email.com -о encrypted.txt secret.txt
```
В результате выполнения данной комманды, на выходе мы получим зашифрованный файл encrypted.txt.
Вы можете убедиться в этом, если попробуете просмотреть содержимое файла с помощью комманды `cat`, в результате выполнения которой, вы увидете некоторое количество нечитаемых символов. Это и есть наш зашифрованный файл. Таким образом мы можем шифровать любые типы файлов, не только текстовые, а например изображения.

Также дополнительно, процесс шифрования скрывает информацию о типе файла из заголовков файла, шифруя ее. Это также помогает обеспечить дополнительную безопасность зашифрованного файла. Обратите внимание, как в примере ниже, зашифрованная картинка в формате png более не определяется системой как графический файл, её тип отображается просто как data:
```bash
file picture.png
picture.png: PNG image data, 1319 x 968, 8-bit/color RGB, non-interlaced
gpg2 -e -r your@email.com -o encrypted_picture.png picture.png 
file encrypted_picture.png
encrypted_picture.png: data
```
## Расшифровка файла
Теперь когда мы успешно зашифровали файл, мы должны научиться расшифровывать его. 
Чтобы расшифровать файлы, мы используем аргумент `-d` (decrypt), как в примере ниже:
```bash
gpg2 -d secret.txt.gpg 
You need a passphrase to unlock the secret key for
user: "Your Name <your@email.com>"
1024-bit ELG-E key, ID 52443CA3, created 2018-03-11 (main key ID 0EF6B359)

Enter passphrase: your passphrase 

gpg2: encrypted with 1024-bit ELG-E key, ID 52443CA3, created 2018-03-11
      "Your Name <your@email.com>"
this is my very secret file
```
GnuPG запросит ваш пароль, который вы задали в процессе генерации ключей. Если вы ввели пароль верно, содержимое файла будет выведено путем стандартного вывода (на экран). Эта не самое практичное решение, тем более, когда речь идет о не-текстовых файлах, поэтому мы воспользуемся уже знакомым вам атрибутом `-o` (output), дабы явно указать имя файла в который будет расшифровано содержимое нашего зашифрованного текстового файла. Ровно так же, как и в примере с шифрованием. В данном случае мы указываем файл decrypted.txt как файл в который будет расшифровано содержимое файла secret.txt.gpg 
```bash
gpg2 -d -o decrypted.txt secret.txt.gpg
```
Это вся базовая информация, которую вам нужно знать, чтобы шифровать и дешифровать файлы для себя. Таким образом теперь вы можете шифровать любые ваши данные и безопасно их хранить, не изучая каких-то дополнительных комманд, пользуясь лишь знаниями полученными здесь. 

Если же вы желаете шифровать файлы для других людей, или принимать зашифрованные файлы от других людей, то вам стоит научиться импортировать и экспортировать public ключи.
